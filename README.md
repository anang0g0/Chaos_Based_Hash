# Chaos_Based_Hash


原理：データバッファをコピーしてそれに置換と、3ビット右巡回シフトと、非線形変換（AESのS-box）したものをコピー前のバッファにXORしているつもり。

これはカオスというよりは、算術的ハッシュ関数です。
カオスはまだ勉強中なので定義も覚えてないし、その意味ではカオスのイメージに触発されてできたハッシュ関数もどきと言えそうです。

ハッシュ関数：https://ja.wikipedia.org/wiki/%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E9%96%A2%E6%95%B0

カオス理論：https://ja.m.wikipedia.org/wiki/%E3%82%AB%E3%82%AA%E3%82%B9%E7%90%86%E8%AB%96


20200713

おおっと！こりゃ重大な設計ミスだｗ。
同じ文字列読ませると0になるｗ。

CTRモードみたいな感じで解決してみました。
理論上カウンタのサイズが64ビットなので、2^64バイトサイズの大きさ以下のデータならハッシュ値が重なることはないと思うのですが小さすぎるでしょうか・・・。

でも、そのまま足すと面白くないし何故か遅いので、xorshiftを使ってみました。手抜きですね。
まあ簡単な算数みたいな設計デス。
この方が解析しやすいし、こんな簡単な作りじゃ安全なものは永遠に出来ないかも知れないですが、気づかないよりマシですね。
もっと正当な設計の仕方を模倣したほうがいいかも知れません。

この行に注目してください。

v[i] ^= Sbox[ROTL8 (f[x1[i]]+c.ar[i], 3)];

こうしたのは＋が一方向だからです。
オーバーフローを起こした部分は消えてしまいます！


20200711

処理が遅かったので高速化しました。
ディスクアクセスが原因で大きなファイルの処理に時間が書かていましたが、
読み込みバッファのサイズを大きくしたことでより大きなサイズのファイルに対しても
高速にハッシュ値を計算できるようになりました。（chash.c）

細かい部分を直しました。

今日の結論：sha256sumと比べると気のせいか1秒くらい早いです。
速度的に見ると勝っているように見えます。データ攪拌も十分だし、性能面でも思った以上に早かったです。
sage-9.0.tar.gzをハッシュした結果、sha256で3.6秒程度、私ので2.8秒くらいなので勝ってます。
まだバグがありそうなので油断はできませんが・・・。

今後の実験によっては、もしかしたら「秘密鍵暗号はカオスの一種ではないか」という予測が正しいのかどうかが分るかもしれません。

何かわかりそうで解らなかったことが整理できた。誤差のないはずの計算機の中で、何がカオスの原因になりうるか？
物理現象では測定器の誤差だけでなく、どれだけ正確なデータを使っても微分方程式を計算するときにどうしても誤差が出てしまう。
その誤差が累積して結果が予測不可能になる。
秘密鍵暗号では誤差はないが、ブラックボックスとして秘密鍵が存在するので、その知り得ない秘密鍵の値がデータに影響して予測不可能な結果になるのだということ。

検証：のちに。（実験と理論的説明が必要。このくらいしないと本当に修士号持っているのか疑わしいですよねｗ。）

検証法：まずこの関数のミニチュア（32ビット）を作って、それがだめな理由を漸化式を使って明らかにする。例えば変数 

unsigned int a=1;

とした時に、１６次元の置換群を使って入れ替えをし、2ビットのブロック単位を１ビット巡回シフトし、更に４要素の適当な配列を使って２ビット単位に変換したものをaにXORする。
巡回シフトが意味を持つためには単一ビットのみの操作では意味がないので、４ビットとか２ビットとかある程度まとまりをもったブロック単位で処理しなければならない。
その時、ブロック単位の数と置換群の次元を対応させる必要がある。
問題なのは、XORしているためある確率で突然すべてが０になってしまう可能性がある。
これを防ぐために+などの演算に処理を変える必要があるかも知れない。
こう考えるとセルオートマトンのライフゲームみたいに思えてきますねｗ。
乱数ではないのでハッシュ値の衝突が起きる確率が無視できる程度であれば合格になるはず。

後日やってみる攻撃：https://ja.wikipedia.org/wiki/%E8%AA%95%E7%94%9F%E6%97%A5%E6%94%BB%E6%92%83

こういう風に、数式で考えるといかにダメな設計かわかってきますね。

こういうものは人に尋ねる前に冷静になって、自分で納得いくまで考える必要を感じる。

参考文献：DES is not a group


20200710

ハッシュになっていないことがわかったので、修正しました。

それどころかカオス暗号は弱いという定評が出ていて、ウィキなんかにも悪い暗号として記載されていました。

では、普通のブロック暗号で計算していることは一体何なのでしょうか？
もし、ブロック暗号の計算がカオス理論で説明できないのであれば、それは一体何を計算していることになるのだろうか？

失敗の原因ですが、バタフライ効果が発揮できていませんでした。
実装ミス。
理想の方法が見つかってからも、同じ出力を持つ別の入力データがないかどうか攻撃します。

20200709

置換群を使ったパイコネ返還からカオスを作り、バタフライ効果でハッシュ関数を作ってみました。
安全性の検証はまだこれからです。
失敗作の予感がしますｗ。
