# Chaos_Based_Hash


原理：データバッファをコピーしてそれに置換と、3ビット右巡回シフトと、非線形変換（AESのS-box）したものをコピー前のバッファにXORしているつもり。

20200711

処理が遅かったので高速化しました。
ディスクアクセスが原因で大きなファイルの処理に時間が書かていましたが、
読み込みバッファのサイズを大きくしたことでより大きなサイズのファイルに対しても
高速にハッシュ値を計算できるようになりました。（chash.c）

細かい部分を直しました。

検証：のちに。

検証法：まずこの関数のミニチュア（32ビット）を作って、それがだめな理由を漸化式を使って明らかにする。例えば変数 

unsigned int a=1;

とした時に、次元３２の置換群を使って入れ替えをし、幾つか１ビット巡回シフトし、更に４要素の適当な配列を使って２ビット単位に変換したものをaにXORする。

こういう風に、数式で考えるといかにダメな設計かわかってきますね。

こういうものは人に尋ねる前に冷静になって、自分で納得いくまで考える必要を感じる。


20200710

ハッシュになっていないことがわかったので、修正しました。

それどころかカオス暗号は弱いという定評が出ていて、ウィキなんかにも悪い暗号として記載されていました。

では、普通のブロック暗号で計算していることは一体何なのでしょうか？
もし、ブロック暗号の計算がカオス理論で説明できないのであれば、それは一体何を計算していることになるのだろうか？

失敗の原因ですが、バタフライ効果が発揮できていませんでした。
実装ミス。
理想の方法が見つかってからも、同じ出力を持つ別の入力データがないかどうか攻撃します。

20200709

置換群を使ったパイコネ返還からカオスを作り、バタフライ効果でハッシュ関数を作ってみました。
安全性の検証はまだこれからです。
失敗作の予感がしますｗ。
